angular.module("kendo.window", []).factory("$$stackedMap", function () { return { createNew: function () { var e = []; return { add: function (n, o) { e.push({ key: n, value: o }) }, get: function (n) { for (var o = 0; o < e.length; o++)if (n == e[o].key) return e[o] }, keys: function () { for (var n = [], o = 0; o < e.length; o++)n.push(e[o].key); return n }, top: function () { return e[e.length - 1] }, remove: function (n) { for (var o = -1, t = 0; t < e.length; t++)if (n == e[t].key) { o = t; break } return e.splice(o, 1)[0] }, removeTop: function () { return e.splice(e.length - 1, 1)[0] }, length: function () { return e.length } } } } }).directive("kWindowFrame", ["$kModalStack", "$q", "$animate", "$injector", function (e, n, o, t) { return t.has("$animateCss") && t.get("$animateCss"), { scope: { index: "@" }, replace: !0, transclude: !0, templateUrl: function (n, o) { return e.getTop().value.windowTemplateUrl || "views/window.html" }, link: function (o, t, r) { o.size = r.size, o.close = function (n) { e.getTop() && null !== n && n.target === n.currentTarget && (n.preventDefault(), n.stopPropagation()) }; var i = e.getTop().value; if (void 0 !== i.options.close) { var a = i.options.close; i.options.close = function (e) { a(), i.deferred.reject(), setTimeout(function () { o.myKendoWindow.destroy() }, 1e3) } } else i.options.close = function (e) { i.deferred.reject(), setTimeout(function () { o.myKendoWindow.destroy() }, 1e3) }; o.options = i.options, t.on("click", o.close), o.$isRendered = !0; var l = n.defer(); r.$observe("modalRender", function (e) { "true" == e && l.resolve() }), l.promise.then(function () { var n = setInterval(function () { void 0 !== o.myKendoWindow && ($("#divDynamicKendoWindow").attr("data-beforeopen", " "), void 0 === o.options.position && o.myKendoWindow.center(), o.myKendoWindow.open(), o.$on(e.NOW_CLOSING_EVENT, function (e, n) { o.done = n(), o.myKendoWindow.close() }), clearInterval(n)) }, 1), t = e.getTop(); t && e.modalRendered(t.key) }) } } }]).directive("kWindowTransclude", function () { return { link: function (e, n, o, t, r) { r(e.$parent, function (e) { n.empty(), n.append(e) }) } } }).factory("$kModalStack", ["$animate", "$timeout", "$document", "$compile", "$rootScope", "$q", "$injector", "$$stackedMap", function (e, n, o, t, r, i, a, l) { a.has("$animateCss") && a.get("$animateCss"); var d = l.createNew(), c = { NOW_CLOSING_EVENT: "modal.stack.now-closing" }; function u(e, n) { var t, r, a, l = o.find("body").eq(0), u = d.get(e).value; d.remove(e), t = u.modalDomEl, (r = u.modalScope).$broadcast(c.NOW_CLOSING_EVENT, function () { return a || (a = i.defer()).promise, function () { a.resolve() } }), setTimeout(function () { t.parent().remove(), r.$destroy() }, 1e3), n && n.focus ? n.focus() : l.focus() } function s(e, n, o) { return !e.value.modalScope.$broadcast("modal.closing", n, o).defaultPrevented } return c.open = function (e, n) { var r = o[0].activeElement; d.add(e, { deferred: n.deferred, renderDeferred: n.renderDeferred, openedDeferred: n.openedDeferred, modalScope: n.scope, options: n.options, windowTemplateUrl: n.windowTemplateUrl }); var i = o.find("body").eq(0), a = angular.element('<div k-window-frame="modal-window"></div>'); a.attr({ "template-url": n.windowTemplateUrl, index: d.length() - 1, animate: "animate" }).html(n.content), n.animation && a.attr("modal-animation", "true"); var l = t(a)(n.scope); d.top().value.modalDomEl = l, d.top().value.modalOpener = r, i.append(l) }, c.close = function (e, n) { var o = d.get(e); return o && s(o, n, !0) ? (o.value.modalScope.$$kDestructionScheduled = !0, o.value.deferred.resolve(n), u(e, o.value.modalOpener), !0) : !o }, c.dismiss = function (e, n) { var o = d.get(e); return o && s(o, n, !1) ? (o.value.modalScope.$$kDestructionScheduled = !0, o.value.deferred.reject(n), u(e, o.value.modalOpener), !0) : !o }, c.dismissAll = function (e) { for (var n = this.getTop(); n && this.dismiss(n.key, e);)n = this.getTop() }, c.getTop = function () { return d.top() }, c.modalRendered = function (e) { var n = d.get(e); n && n.value.renderDeferred.resolve() }, c }]).provider("$kWindow", function () { var e = { options: { animation: !1, keyboard: !0 }, $get: ["$injector", "$rootScope", "$q", "$templateRequest", "$controller", "$kModalStack", function (n, o, t, r, i, a) { var l = {}, d = null; return l.getPromiseChain = function () { return d }, l.open = function (l) { var c = t.defer(), u = t.defer(), s = t.defer(), p = null, f = { id: a.length, result: c.promise, opened: u.promise, rendered: s.promise, close: function (e) { return a.close(f, e) }, dismiss: function (e) { return a.dismiss(f, e) } }; if ((l = angular.extend({}, e.options, l)).resolve = l.resolve || {}, !l.template && !l.templateUrl) throw new Error("One of template or templateUrl options is required."); var m, v, $, w, g = t.all([($ = l, $.template ? t.when($.template) : r(angular.isFunction($.templateUrl) ? $.templateUrl() : $.templateUrl))].concat((m = l.resolve, v = [], angular.forEach(m, function (e) { angular.isFunction(e) || angular.isArray(e) ? v.push(t.when(n.invoke(e))) : angular.isString(e) ? v.push(t.when(n.get(e))) : v.push(t.when(e)) }), v))); function h() { return g } return w = d = t.all([d]).then(h, h).then(function (e) { (p = (l.scope || o).$new()).$close = f.close, p.$dismiss = f.dismiss, p.$on("$destroy", function () { p.$$kDestructionScheduled || p.$dismiss("$kUnscheduledDestruction") }); var n, t = {}, r = 1; l.controller && (t.$scope = p, t.$windowInstance = f, angular.forEach(l.resolve, function (n, o) { t[o] = e[r++] }), n = i(l.controller, t), l.controllerAs && (l.bindToController && angular.extend(n, p), p[l.controllerAs] = n)), a.open(f, { scope: p, deferred: c, openedDeferred: u, renderDeferred: s, content: e[0], options: void 0 === l.options ? {} : l.options, windowTemplateUrl: l.windowTemplateUrl }) }, function (e) { u.reject(e), c.reject(e) }).finally(function () { d === w && (d = null) }), f }, l }] }; return e });